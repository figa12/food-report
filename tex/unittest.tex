The mobile application is designed to be a thin client that sends and recieves messages to and from the server. Because of this we have chosen to focus our testing on the server, if the server has a 100\% code coverage and all tests are satisfied, we only need to ensure that the mobile application sends a correct message, and we can guarantee that the result is correct.
The server layer consists of a class that handles all connection to the database, the goal is to achieve 100\% method coverage on this class.

To avoid corrupting the data that is running on production we have made a script that makes an exact copy of the database to perform all of the testing on. An example of how the testing could corrupt the database is that a when the test is run a recipe will be created to ensure that this functionality works. If this recipe, for any reason, could not get deleted again it would be possible for the users to see this recipe. The copying of the database could prove to be a bottleneck if the application were to get very big, but in current state it only takes a few seconds.

The unit tests are run using ``PHPUnit'' version 3.6.10 by Sebastian Bergmann\cite{phpunit}, furthermore mutation tests are run using ``judgedim/mutagenesis''\cite{mutagenesis}. The basic approach of using PHPUnit is to create a new file that includes the functions which should be tested, the new file must have a new class that extends\linebreak \lstinline|PHPUnit_Framework_TestCase|. All public methods, in this new class, which are named with a prefix of \lstinline|test| will be included in the test. Inside each of these methods all kinds of assertions can be made, an example could be \lstinline|$this->assertNotNull($var)|\citep{phpunit}.

To demonstrate how we have performed the unit tests, the tests \inline{testSetRecipe()} and \inline{testGetRecipe()} have been included. These tests ensure that when a new recipe is written to the database, the exact same recipe can be retrieved again with no missing data.

\begin{lstlisting}[language=phpstyle]
    /**
     * @depends testSetUnit
     * @depends testSetIngredient
     * @covers DB::setRecipe
     */
    public function testSetRecipe($unit, $ingredient) {
        $url = 'http://localhost/food/lib/recipebackend.php';

        $fields = array(
            'test'=>"true",
            'recipeName'=>$this->recipeName,
            'recipeDesc'=>$this->recipeDesc,
            'group1'=>$this->groupName,
            'group1_exchange1'=>"",
            'group1_exchange1_mandatory'=>$this->firstExchangeMandatory,
            'group1_exchange1_ingredient1'=>$ingredient,
            'group1_exchange1_ingredient1_amount'=>$this->firstIngAmount,
            'group1_exchange1_ingredient1_unit'=>$unit,
            'step1'=>$this->firstStepDesc,
            'step2'=>$this->secondStepDesc
            );
        
        $result = $this->sendCurl($url, $fields);
        $this->assertNotNull($result);
            
        $resultRecipeId = (int)strip_tags($result);
        $this->assertGreaterThan(0, $resultRecipeId);
        
        return $resultRecipeId;
      }
\end{lstlisting}

\begin{description}
\item[Lines 2-3] The test depends on both \inline{testSetUnit()} and \inline{setSetIngredient}, we need both ingredients and a unit of measurement to create a recipe.
\item[Line 4] We specify that this test covers the \inline{setRecipe()} method in the \inline{DB} class. This is because the code coverage analysis tool does not properly detect coverage when using cURL\cite{curl}.
\item[Line 6] \inline{testSetRecipe()} takes two parameters: the id of the inserted unit of measurement from \inline{testSetUnit()} and the id from \inline{testSetIngredient()} respectively.
\item[Line 7] The \inline{$url} variable is initialised to the value address of the file that handles creation of recipes. \textit{recipebackend.php} is used by the recipe creator tool.%$
\item[Lines 9-21] An array is initialised with key value pairs that represent the POST variables that is send to the given url.
\item[Line 23] The request is send to the server with the given POST variables and the result is stored in \inline{$result}.%$
\item[Line 24] It is checked that the result is not null. If the result were null it would mean that something went wrong while inserting the data.
\item[Lines 26-27] The id of the newly inserted recipe must be greater than 0.
\item[Line 29] Return the id of the insert recipe. This id is used by the \inline{testGetRecipe()} method to check that we can extract the recipe correctly again.
\end{description}

\begin{lstlisting}
    /**
     * @depends testSetRecipe
     */
    public function testGetRecipe($recipeId) {
        $jsonResult = self::$DB->getRecipe($recipeId, $this->language, $this->metric);
        $recipe = json_decode($jsonResult);

        //Check that the recipe is equal to the one we inserted.
        $this->assertEquals($recipeId, $recipe->id);
        $this->assertEquals($this->recipeName, $recipe->name);
        $this->assertEquals($this->recipeDesc, $recipe->desc);
        $this->assertEquals($this->recipeImage, $recipe->image);
        $this->assertEquals($this->groupName, $recipe->groups[0]->name);
        $this->assertNotNull($recipe->groups[0]->order);
        $this->assertEquals($this->ingredientName, $recipe->groups[0]->exchanges[0]->ingredients[0]->name);
        $this->assertEquals($this->firstIngAmount, $recipe->groups[0]->exchanges[0]->ingredients[0]->amount);
        $this->assertEquals($this->metricName, $recipe->groups[0]->exchanges[0]->ingredients[0]->unit);

        $this->assertEquals(((bool)$this->firstExchangeMandatory), $recipe->groups[0]->exchanges[0]->mandatory);
    }
\end{lstlisting}%$

\begin{description}
\item[Lines 2] The test depends on \inline{testSetRecipe()}.
\item[Line 4] \inline{testGetRecipe()} takes the id that was returned from \inline{testSetRecipe} as a parameter.
\item[Lines 5-6] The method to get a recipe is called from the \inline{DB} class, and the result is JSON decoded. This enables us to handle the result as a PHP object.
\item[Line 7] The \inline{$url} variable is initialised to the value address of the file that handles creation of recipes. \textit{recipebackend.php} is used by the recipe creator tool.%$
\item[Lines 9-19] Numerous assertions are made to ensure that the data in the fetched object is equal to the data we used when writing the recipe to the database.
\end{description}

\subsection*{Result}
\begin{lstlisting}[numbers=none, basicstyle=\ttfamily, caption={The result of the PHPUnit test}]
Time: 1 second, Memory: 3.75Mb
OK (16 tests, 45 assertions)
\end{lstlisting}
The goal was to achieve 100\% code coverage of the \inline{DB} class and as seen in \appref{app:coverage} this was succeeded. All of the tests passes and from this we can conclude that all of the functionality on the server works as intended. As long as the mobile application send the correct data of the correct format, we can ensure that a valid response is sent back.

The tests have been run trough a mutation testing tool and gives a success rate of 76.67\%. The reason behind mutation testing is to check how good the tests are by altering the source code. If any tests pass while the source code is altered it is considered defective. The percentage of escaped mutations could and should be reduced, but we simply ran out of time.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../master"
%%% End: 
